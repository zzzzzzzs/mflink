import { ApplicationInitStatus, SimpleChange, ChangeDetectorRef, NgZone, Component } from '@angular/core';
import { TestBed, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { NoopAnimationsModule, BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { Router } from '@angular/router';
import { RouterTestingModule } from '@angular/router/testing';
import { configure as configure$1, prettyDOM, getQueriesForElement, waitFor as waitFor$1, waitForElementToBeRemoved as waitForElementToBeRemoved$1, screen as screen$1 } from '@testing-library/dom';
export { buildQueries, createEvent, findAllByAltText, findAllByDisplayValue, findAllByLabelText, findAllByPlaceholderText, findAllByRole, findAllByTestId, findAllByText, findAllByTitle, findByAltText, findByDisplayValue, findByLabelText, findByPlaceholderText, findByRole, findByTestId, findByText, findByTitle, fireEvent, getAllByAltText, getAllByDisplayValue, getAllByLabelText, getAllByPlaceholderText, getAllByRole, getAllByTestId, getAllByText, getAllByTitle, getByAltText, getByDisplayValue, getByLabelText, getByPlaceholderText, getByRole, getByTestId, getByText, getByTitle, getDefaultNormalizer, getElementError, getNodeText, getQueriesForElement, getRoles, isInaccessible, logDOM, logRoles, prettyDOM, queries, queryAllByAltText, queryAllByAttribute, queryAllByDisplayValue, queryAllByLabelText, queryAllByPlaceholderText, queryAllByRole, queryAllByTestId, queryAllByText, queryAllByTitle, queryByAltText, queryByAttribute, queryByDisplayValue, queryByLabelText, queryByPlaceholderText, queryByRole, queryByTestId, queryByText, queryByTitle, queryHelpers, within } from '@testing-library/dom';

let config = {
    dom: {},
    defaultImports: [],
};
function configure(newConfig) {
    if (typeof newConfig === 'function') {
        // Pass the existing config out to the provided function
        // and accept a delta in return
        newConfig = newConfig(config);
    }
    // Merge the incoming config delta
    config = Object.assign(Object.assign({}, config), newConfig);
}
function getConfig() {
    return config;
}

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var _a;
const mountedFixtures = new Set();
const inject = TestBed.inject || TestBed.get;
function render(sut, renderOptions = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const _a = getConfig(), { dom: domConfig } = _a, globalConfig = __rest(_a, ["dom"]);
        const { detectChanges: detectChangesOnRender = true, declarations = [], imports = [], providers = [], schemas = [], queries, template = undefined, wrapper = WrapperComponent, componentProperties = {}, componentProviders = [], excludeComponentDeclaration = false, routes, removeAngularAttributes = false, defaultImports = [], } = Object.assign(Object.assign({}, globalConfig), renderOptions);
        configure$1(Object.assign({ eventWrapper: (cb) => {
                const result = cb();
                detectChangesForMountedFixtures();
                return result;
            } }, domConfig));
        TestBed.configureTestingModule({
            declarations: addAutoDeclarations(sut, {
                declarations,
                excludeComponentDeclaration,
                template,
                wrapper,
            }),
            imports: addAutoImports({
                imports: imports.concat(defaultImports),
                routes,
            }),
            providers: [...providers],
            schemas: [...schemas],
        });
        if (componentProviders) {
            componentProviders
                .reduce((acc, provider) => acc.concat(provider), [])
                .forEach((p) => {
                const { provide } = p, provider = __rest(p, ["provide"]);
                TestBed.overrideProvider(provide, provider);
            });
        }
        const fixture = yield createComponentFixture(sut, { template, wrapper });
        setComponentProperties(fixture, { componentProperties });
        if (removeAngularAttributes) {
            fixture.nativeElement.removeAttribute('ng-version');
            const idAttribute = fixture.nativeElement.getAttribute('id');
            if (idAttribute && idAttribute.startsWith('root')) {
                fixture.nativeElement.removeAttribute('id');
            }
        }
        mountedFixtures.add(fixture);
        yield TestBed.compileComponents();
        let isAlive = true;
        fixture.componentRef.onDestroy(() => (isAlive = false));
        function detectChanges() {
            if (isAlive) {
                fixture.detectChanges();
            }
        }
        // Call ngOnChanges on initial render
        if (hasOnChangesHook(fixture.componentInstance)) {
            const changes = getChangesObj(null, componentProperties);
            fixture.componentInstance.ngOnChanges(changes);
        }
        if (detectChangesOnRender) {
            detectChanges();
        }
        const rerender = (rerenderedProperties) => {
            const changes = getChangesObj(fixture.componentInstance, rerenderedProperties);
            setComponentProperties(fixture, { componentProperties: rerenderedProperties });
            if (hasOnChangesHook(fixture.componentInstance)) {
                fixture.componentInstance.ngOnChanges(changes);
            }
            fixture.componentRef.injector.get(ChangeDetectorRef).detectChanges();
        };
        let router = routes ? inject(Router) : null;
        const zone = inject(NgZone);
        const navigate = (elementOrPath, basePath = '') => __awaiter(this, void 0, void 0, function* () {
            if (!router) {
                router = inject(Router);
            }
            const href = typeof elementOrPath === 'string' ? elementOrPath : elementOrPath.getAttribute('href');
            const [path, params] = (basePath + href).split('?');
            const queryParams = params
                ? params.split('&').reduce((qp, q) => {
                    const [key, value] = q.split('=');
                    // TODO(Breaking): group same keys qp[key] ? [...qp[key], value] : value
                    qp[key] = value;
                    return qp;
                }, {})
                : undefined;
            const navigateOptions = queryParams
                ? {
                    queryParams,
                }
                : undefined;
            const doNavigate = () => (navigateOptions ? router.navigate([path], navigateOptions) : router.navigate([path]));
            let result;
            if (zone) {
                yield zone.run(() => (result = doNavigate()));
            }
            else {
                result = doNavigate();
            }
            detectChanges();
            return result;
        });
        return Object.assign({ fixture,
            detectChanges,
            navigate,
            rerender, debugElement: typeof sut === 'string' ? fixture.debugElement : fixture.debugElement.query(By.directive(sut)), container: fixture.nativeElement, debug: (element = fixture.nativeElement, maxLength, options) => Array.isArray(element)
                ? element.forEach((e) => console.log(prettyDOM(e, maxLength, options)))
                : console.log(prettyDOM(element, maxLength, options)) }, replaceFindWithFindAndDetectChanges(getQueriesForElement(fixture.nativeElement, queries)));
    });
}
function createComponent(component) {
    return __awaiter(this, void 0, void 0, function* () {
        /* Make sure angular application is initialized before creating component */
        yield inject(ApplicationInitStatus).donePromise;
        return TestBed.createComponent(component);
    });
}
function createComponentFixture(sut, { template, wrapper }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof sut === 'string') {
            TestBed.overrideTemplate(wrapper, sut);
            return createComponent(wrapper);
        }
        if (template) {
            TestBed.overrideTemplate(wrapper, template);
            return createComponent(wrapper);
        }
        return createComponent(sut);
    });
}
function setComponentProperties(fixture, { componentProperties = {} }) {
    var _a;
    for (const key of Object.keys(componentProperties)) {
        const descriptor = Object.getOwnPropertyDescriptor(fixture.componentInstance.constructor.prototype, key);
        let _value = componentProperties[key];
        const defaultGetter = () => _value;
        const extendedSetter = (value) => {
            var _a;
            _value = value;
            (_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set) === null || _a === void 0 ? void 0 : _a.call(fixture.componentInstance, _value);
            fixture.detectChanges();
        };
        Object.defineProperty(fixture.componentInstance, key, {
            get: (descriptor === null || descriptor === void 0 ? void 0 : descriptor.get) || defaultGetter,
            set: extendedSetter,
            // Allow the property to be defined again later.
            // This happens when the component properties are updated after initial render.
            // For Jest this is `true` by default, for Karma and a real browser the default is `false`
            configurable: true,
        });
        (_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set) === null || _a === void 0 ? void 0 : _a.call(fixture.componentInstance, _value);
    }
    return fixture;
}
function hasOnChangesHook(componentInstance) {
    return ('ngOnChanges' in componentInstance && typeof componentInstance.ngOnChanges === 'function');
}
function getChangesObj(oldProps, newProps) {
    const isFirstChange = oldProps === null;
    return Object.keys(newProps).reduce((changes, key) => (Object.assign(Object.assign({}, changes), { [key]: new SimpleChange(isFirstChange ? null : oldProps[key], newProps[key], isFirstChange) })), {});
}
function addAutoDeclarations(sut, { declarations, excludeComponentDeclaration, template, wrapper, }) {
    if (typeof sut === 'string') {
        return [...declarations, wrapper];
    }
    const wrappers = () => (template ? [wrapper] : []);
    const components = () => (excludeComponentDeclaration ? [] : [sut]);
    return [...declarations, ...wrappers(), ...components()];
}
function addAutoImports({ imports, routes }) {
    const animations = () => {
        const animationIsDefined = imports.indexOf(NoopAnimationsModule) > -1 || imports.indexOf(BrowserAnimationsModule) > -1;
        return animationIsDefined ? [] : [NoopAnimationsModule];
    };
    const routing = () => (routes ? [RouterTestingModule.withRoutes(routes)] : []);
    return [...imports, ...animations(), ...routing()];
}
/**
 * Wrap waitFor to invoke the Angular change detection cycle before invoking the callback
 */
function waitForWrapper(detectChanges, callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let inFakeAsync = true;
        try {
            tick(0);
        }
        catch (err) {
            inFakeAsync = false;
        }
        detectChanges();
        return yield waitFor$1(() => {
            setTimeout(() => detectChanges(), 0);
            if (inFakeAsync) {
                tick(0);
            }
            return callback();
        }, options);
    });
}
/**
 * Wrap waitForElementToBeRemovedWrapper to poke the Angular change detection cycle before invoking the callback
 */
function waitForElementToBeRemovedWrapper(detectChanges, callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let cb;
        if (typeof callback !== 'function') {
            const elements = (Array.isArray(callback) ? callback : [callback]);
            const getRemainingElements = elements.map((element) => {
                let parent = element.parentElement;
                while (parent.parentElement) {
                    parent = parent.parentElement;
                }
                return () => (parent.contains(element) ? element : null);
            });
            cb = () => getRemainingElements.map((c) => c()).filter(Boolean);
        }
        else {
            cb = callback;
        }
        return yield waitForElementToBeRemoved$1(() => {
            const result = cb();
            detectChanges();
            return result;
        }, options);
    });
}
function cleanup() {
    mountedFixtures.forEach(cleanupAtFixture);
}
function cleanupAtFixture(fixture) {
    fixture.destroy();
    if (!fixture.nativeElement.getAttribute('ng-version') && fixture.nativeElement.parentNode === document.body) {
        document.body.removeChild(fixture.nativeElement);
    }
    mountedFixtures.delete(fixture);
}
// if we're running in a test runner that supports afterEach
// then we'll automatically run cleanup afterEach test
// this ensures that tests run in isolation from each other
// if you don't like this, set the ATL_SKIP_AUTO_CLEANUP env variable to 'true'
if (typeof process === 'undefined' || !((_a = process.env) === null || _a === void 0 ? void 0 : _a.ATL_SKIP_AUTO_CLEANUP)) {
    if (typeof afterEach === 'function') {
        afterEach(() => {
            cleanup();
        });
    }
}
// TODO: rename to `atl-wrapper-component`
// eslint-disable-next-line @angular-eslint/component-selector
class WrapperComponent {
}
WrapperComponent.decorators = [
    { type: Component, args: [{ selector: 'wrapper-component', template: '' },] }
];
/**
 * Wrap findBy queries to poke the Angular change detection cycle
 */
function replaceFindWithFindAndDetectChanges(originalQueriesForContainer) {
    return Object.keys(originalQueriesForContainer).reduce((newQueries, key) => {
        const getByQuery = originalQueriesForContainer[key.replace('find', 'get')];
        if (key.startsWith('find') && getByQuery) {
            newQueries[key] = (text, options, waitOptions) => __awaiter(this, void 0, void 0, function* () {
                // original implementation at https://github.com/testing-library/dom-testing-library/blob/main/src/query-helpers.js
                const result = yield waitForWrapper(detectChangesForMountedFixtures, () => getByQuery(text, options), waitOptions);
                return result;
            });
        }
        else {
            newQueries[key] = originalQueriesForContainer[key];
        }
        return newQueries;
    }, {});
}
/**
 * Call detectChanges for all fixtures
 */
function detectChangesForMountedFixtures() {
    mountedFixtures.forEach((fixture) => {
        try {
            fixture.detectChanges();
        }
        catch (err) {
            if (!err.message.startsWith('ViewDestroyedError')) {
                throw err;
            }
        }
    });
}
/**
 * Re-export screen with patched queries
 */
const screen = replaceFindWithFindAndDetectChanges(screen$1);
/**
 * Re-export waitFor with patched waitFor
 */
function waitFor(callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return waitForWrapper(detectChangesForMountedFixtures, callback, options);
    });
}
/**
 * Re-export waitForElementToBeRemoved with patched waitForElementToBeRemoved
 */
function waitForElementToBeRemoved(callback, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return waitForElementToBeRemovedWrapper(detectChangesForMountedFixtures, callback, options);
    });
}

/*
 * Public API Surface of testing-library
 */

/**
 * Generated bundle index. Do not edit.
 */

export { configure, getConfig, render, screen, waitFor, waitForElementToBeRemoved };
//# sourceMappingURL=testing-library-angular.js.map
